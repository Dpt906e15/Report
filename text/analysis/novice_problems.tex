\chapter{Error-Prone Areas for Novices}
\label{chap:error-prone_areas_for_novices}
For a person new to programming, different constructs and concepts can be so confusing that this person might give up without much effort. This area is of great interest to many studies, as it can help future generations in learning programming with ease. But to find solutions, the difficulties that can arise when learning programming and the concepts that follow must be known.

This chapter focuses on the different aspects of learning programming that can be difficult to grasp for novices. The different aspects and concepts are found by previous studies as well as subjective speculation.

\section{Syntax and Semantics}
As known, a programming language is based on the syntactical rules and the semantic relations. These concepts can be hard to grasp at first, and can be even harder to understand in relation and when used in a practical solution.

One of the most error prone areas for novice programmers is the basic syntax \cite{Garner05}. This consists of brackets, semicolons, commas, and other such symbols, symbolizing control for the program. This problem might relate to an even greater problem in understanding the strict control that is needed when writing code in general. When writing code, even the smallest mistake or forgotten symbol leads to a compiler error. This error margin isn't seen very often in other lines of work, and might discourage the novices from keep trying.

Understanding what a line of code does in itself might be hard for some new programmers. Understanding the connection of the whole program, and what the single line does for the result is even harder. The semantics can lead to confusion, as the program grows bigger. Some times, the novice programmer is even discouraged from even trying, as the connection between the code and what it results in is not clear.

\section{Pragmatics}
A programming language is built on syntax and semantics. To learn how this works can be effective in programming, but programmers often don't think in these terms. Experienced programmers know their way around the basic programming principles and constructs, which is more or less the same in all languages. Programmers often think in patterns, some standardized way for them to program. The logic composition of the elements at hand is often the key for most, working on the idea, in stead of the specific language's behaviour. Even though all programmers have a pattern of programming, good or bad, there is a base line for standard programming patterns. They vary slightly from paradigm to paradigm, but at some level, there is a common thought on the structuring of code. This common coding practice is hard to find and to measure, which leads to no empirical work around this area, which can be used for a further evaluation. Although, it should be taken into account that this way of finding code patterns might be much more useful than teaching syntax and semantics.


\section{Programming Paradigms}
Different paradigms each have their different difficulties. Many programmers first touch programming through an imperative approach. Others start out with an object oriented programming language. 

Imperative programming has its values in its very straight forward and easily trackable nature. On the other hand, it is hard to see the connection to real world problem solutions, as the very strict text-based structure doesn't resemble these much. Nevertheless, certain tools are used today for teaching, such as Scratch (have we described these yet?), which makes imperical programming a valid learning approach.

Object oriented programming (OOP) has it's values in representing real world problems, and how a solution can be modelled. As OOP is mostly based on classes, being the static description of an object, and objects, being the dynamic model of a real world phenomenon, the concepts of the paradigm can be easily grasped. Of course, this fact demands a teaching method suitable for the novice programmers being taught. On the other hand, OOP is often in relation to imperative programming seen as not being something else, but the same, only with object oriented features \cite{Garner05}. This leads to a problem of both understanding the very basic concepts of programming, such as control structures (loops and selections), along with understanding the object oriented approach.

Functional programming (FP) is a paradigm which uses lambda functions, instead of procedures or objects, as the building blocks of a program. Having its roots in lambda calculus, computations in FP are treated as the evaluation of functions where change of state is avoided and the data is immutable which, in turn, prevents the introduction of side effects in programs \cite{func_programming}. Additionally, many concepts of the imperative approach can be simulated in Functional programming(ex. control structures are expressed in terms of recursion), giving as much of a control or power when building programs. However, the notion of using functions as a natural abstraction instead of objects modelled after the world introduces difficulties for novice programmers in understanding the fundamental concepts of Functional programming. Therefore the paradigm is rarely selected as a choice of teaching programming in introductory courses \cite{TeachFuncProgramming}.

It is a wide discussion to determine what approach is the most efficient teaching method. The necessity of learning concepts of OOP before learning to code can be argued, as well as it can be argued that the basic constructs are necessary before learning about different paradigms and advanced structures. The imperative approach is being taught in elementary school in various countries. In OOP, the question is often what teaching methods are used to make students understand the concepts of the paradigm. Studies have shown a better effect when teaching about the concepts before actually coding \cite{Xinogalos15}. Another approach to pursue could be the ``object-first approach''. As the name implies, this approach searches to understand the logic behind objects before anything else. This method can both imply teaching concepts or coding before anything else, and can both be used by novices or by students that have already learned the basics of programming. Although, there is still discussion on whether novices should be taught through this approach, or the classic ``algorithms-first approach'' \cite{Periyamasy12} \todo{fix cite}. One drawback is the fact that the concepts of OOP might be seen by the novices as the basics for programming itself, instead of the basic concepts, which could lead to a block when exploring other paradigms.

Some modern languages, such as C\# and Java, have become what one might call a ``multi-paradigm language''. In these examples, they started out being OOP languages, but now they have implemented various features of other paradigms, such as functional and logic programming. These languages could be considered when learning to program, as the drawback from changing to other languages could be limited.