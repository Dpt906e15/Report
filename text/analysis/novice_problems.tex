\chapter{Error-Prone Areas for Novices}
\label{chap:error-prone_areas_for_novices}
For a person new to programming, different constructs and concepts can be so confusing that this person might give up without much effort. This chapter focuses on the different aspects of learning programming that can be difficult to grasp for novices. The different aspects and concepts are found by previous studies as well as personal experience and subjective speculation.

\section{Syntax and Semantics}
A programming language is based on the syntactical rules and the semantic relations. These concepts can be hard to grasp at first, and can be even harder to understand in relation and when used in a practical solution.

One of the most error prone areas for novice programmers is the basic syntax \cite{Garner05}. This consists of brackets, semicolons, commas, and other such symbols, representing control for the program. This problem might relate to an even greater problem in understanding the strict control that is needed when writing code in general. When writing code, even the smallest mistake or forgotten symbol might lead to a compiler error. This error margin is not seen very often when learning other skills, and might discourage the novices from continuing to try.

Understanding what a line of code does in itself might be hard for some new programmers. Understanding what the single line does for the result in the scope of the whole program is even harder. The semantics can lead to confusion, as the program grows bigger. Sometimes, the novice programmer is discouraged from even trying, as the connection between the code and what it results in is not clear.

\section{Pragmatics}
A programming language is built on syntax and semantics. To learn how this works can be effective in programming, but programmers often do not think in these terms. Experienced programmers know their way around the basic programming principles and constructs, which is more or less the same in all languages. Programmers often think in patterns, some standardized way for them to program. The logic composition of the elements at hand is often the key for most programmers instead of the specific language's behaviour. Even though all programmers have a pattern of programming, good or bad, there is a base line for standard programming patterns. They vary slightly from paradigm to paradigm, but at some level, there is a common thought on the structuring of code. This common coding practice of using pragmatics is hard to find and to measure, which leads to no empirical work within this area that can be used for a further evaluation. Although, it should be taken into account that teaching pragmatics might be much more useful than teaching syntax and semantics.


\section{Programming Paradigms}
Different paradigms each have their different difficulties. Some programmers first touch programming through an imperative approach. Others start out with an object oriented programming language. Some have their first experiences programming in a functional programming language.

Imperative programming has its values in its very straightforward and easily trackable nature. On the other hand, it is hard to see the connection to real world problem solutions, as the very strict text-based structure doesn't resemble these much. Nevertheless, certain tools are used today for teaching, such as Scratch, which makes imperative programming a valid learning approach.

Object oriented programming (OOP) has its values in representing real world problems, and how a solution can be modelled. As OOP is mostly based on classes, being the static description of an object, and objects, being the dynamic model of a real world phenomenon, the concepts of the paradigm can be easily grasped. Of course, this fact demands a teaching method suitable for the novice programmers being taught. In relation to imperative programming OOP is often seen as not being something else, but the same, only with object oriented features \cite{Garner05}. This leads to a problem of both understanding the very basic concepts of programming, such as control structures (loops and selections), along with understanding the object oriented approach. The Object-first approach tries to avoid this problem, by teaching OOP before imperative programming.

Functional programming (FP) is a paradigm which uses lambda functions, instead of procedures or objects, as the building blocks of a program. Having its roots in lambda calculus, computations in FP are treated as the evaluation of functions where change of state is avoided and the data is immutable which, in turn, prevents the introduction of side effects in programs \cite{func_programming}. Additionally, many concepts of the imperative approach can be simulated in Functional programming(e.g. looping control structures are expressed in terms of recursion), giving as much expressivity when building programs. However, the notion of using functions as a natural abstraction instead of objects modelled after the world introduces difficulties for novice programmers in understanding the fundamental concepts of Functional programming. Therefore the paradigm is rarely selected as a choice of teaching programming in introductory courses \cite{TeachFuncProgramming}.

It is a wide discussion to determine what paradigm is the most efficient when teaching. The necessity of learning concepts of OOP before learning to code can be argued, as well as it can be argued that the basic constructs are necessary before learning about different paradigms and advanced structures. The imperative approach is being taught in elementary school in various countries \cite{dk_scratch}. In OOP, the question is often what teaching methods are used to make students understand the concepts of the paradigm. Studies have shown a better effect when teaching about the concepts before actually coding \cite{Xinogalos15}. One teaching method that implements this is the ``object-first approach''. As the name implies, this approach searches to understand the logic behind objects before anything else. This method can both imply teaching concepts or coding before anything else, and can both be used by novices or by students that have already learned the basics of programming. Although, there is still discussion on whether novices should be taught through this approach, or the classic ``algorithms-first approach'' \cite{Periyamasy12}. One drawback is the fact that the concepts of OOP might be seen by the novices as the basics of programming itself, instead of the basic concepts, which could lead to a block when exploring other paradigms.

Some modern languages, such as C\# and Java, have become what one might call a ``multi-paradigm language''. In these examples, they started out being OOP languages, but now they have implemented various features of other paradigms, such as functional and logic programming. These languages could be considered when learning to program, as the drawback from changing to other languages could be limited.